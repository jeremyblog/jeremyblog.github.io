---
layout: post
title: Zookeeper的配置管理(一)
---
这个章节适合所有的读者
<br>
之前的一个项目，在一个较好性能的虚拟机上(4核、16G)的机器上运行一个5个节点的zookeeper集群，由于我们的节点很多(1000个)，且对元数据的编写较为频繁。偶发Zookeeper在更新元数据很慢的问题，但是CPU和内存指标均是正常的，且当次提交的数据也没有超过1M，问题比较奇怪。
<br>
后来经过技术定位，发现是zookeeper在输出事务日志时非常缓慢，而原因却是日志输出的IO设备业务繁忙时被大量占用，导致了zookeeper的输出非常忙。后来使用了单独的IO设备供zookeeper使用才得以解决了问题。
<br>
可见，了解zookeeper的配置是非常重要的。
<br>
<br>
Zookeeper服务器在启动时，会读取zoo.cfg的配置文件，我们也可以通过java的系统属性来传递配置项，格式通常为zookeeper.propertyName(启动的时候，通过-Dzookeeper.propertyName启动jvm，这个和通常的系统属性配置类似，不再这里阐述了)。
### 通用配置
通用配置为每个实例必须设置的项，大部分都有默认值
<br>
**clientPort**
和clientPortAddress参数类似，定义了客户端连接服务器是需要监听的TCP端口，默认为2181。
<br>
**dataDir和dataLogDir**
<br>
dataDir 指定(内存数据库保存的)快照输出的目录，通常dataDire不需要配置到一个专用存储设备上，因为快照会以值守方式异步写入，且不会锁定内存数据库。 
但是dataLogDir对设备的要求需要更高一点，这个与zookeeper的原理有关，Zookeeper在对元数据等进行操作前，需要先按顺序写入事务日志，如果在写日志时由于IO设备过于忙碌，将会影响写入的吞吐能力，这种情况最好将dataLogDir的目录指向独享或者不频繁的设备。
<br>
**tickTime**
<br>
单位为毫秒，客户端会话的最小超时时间为2倍的tickTime，这个值默认值为3000毫秒。增大还是减小需要结合具体的网络环境河配置。因为太小可以帮助我们更快的发现超时的问题，但是也会导致更高的CPU使用率和更高的网络流量(特别是客户端很多的场景)，而且误报的几率更大。
<br>
### 存储配置
以下配置最好关注
<br>
**preAllcSize**
事务日志文件的大小，以KB位单位，默认值64M。如果每次快照之间的日志数量很小，且每个事务本身也很小，64m的默认值显然就很大了。比如我们没1000个事务进行一次快照(snapCount选项)，每个事务(一次元数据修改就是一个事务)的平均大小为100字节，那么100K的preAllcSize应该更合适。
<br>
**snapCount**
默认值为100000，
当Zookeeper服务器重启时需要恢复其状态，恢复需要的时间为读取快照以及(快照启动后)发生的事务的执行时间。因为快照会影响性能，所以集群中所有的服务器最好不要同一时间进行快照操作。
注意。虽然snapCount数已经达到，但是如果前一个快照正在进行，新的快照将不会开始，而是等到下一个snapCount数量的事务后再开启一个新的快照。
<br>
**autopurge.snapRetainCount**
zookeeper会定时清理快照数据，这个配置是在垃圾回收时保留的快照数量。最小值也是默认值为3。
<br>
**autopurge.purgeInterval**
快照和日志清理的时间间隔，设置为0将不会进行清理。
<br>
**traceFile**
Zookeeper的操作的跟踪日志，文件名为traceFile.year.month.day。默认不会开启跟踪工鞥呢，除非设置了这个选项。
这个选项提供了zookeeper操作的详细视图，对于监控很有帮助，不过考虑到CPU和磁盘资源的竞争，建议不要将跟踪文件和上述的日志放在同一个设备中。
注意，如果采用JAVA的属性方式来配置这个属性，请不要在在前面加zookeeper，这个和其它的选项是很不同的。
<br>