---
title: zookeeper应用场景
layout: post
---
此章节适合有初步使用zookeeper的经验及以上的用户

分布式的定义： 分布式系统是同时跨越__多个物理主机，多个独立组件__所组成的系统。
简单地说，进程是多JVM间的并发，数据的共享是其重点(进程间为通信),共享有两种选择：
直接通过网络进行信息交换，或读写某些共享存储，zookeeper就是后者。

### CAP理论
就是一致性、可用性、分区容灾性三者，只能3选2。
这个理论在过去一直被证明是正确的，现在虽有争论，但是用来说明zookeeper还是合适的。zookeeper是集运共享存储来实现信息交换的，需要协作的分布式系统都会用到锁，常见的比如JVM中乐观锁、排它锁什么的。可惜跨进程的分布式系统无法满足，但是锁的要点是一致性，所以支持强一致性zookeeper可以很好的满足了多JVM分布式锁的需求。而可用性是所有系统的非功能性要求，理由很简单，没有客户端愿意相信一个随后宕机的系统。
zookeeper放弃了分区容灾性的保证，这点和可用性似乎相悖的，因为跨机房、跨区域部署是现在平台保证可用性的重要手段，而是交给用户自己去实现。

### 配置管理和数据分发
前面说了，zookeeper是通过读写共享存储来实现进程间协作的，其天生就能保证多JVM间的数据操作一致性，所以在多进程间的管理配置是其与生俱来的能力。另外通过watcher接口，zookeeper可以提供用户监控数据变化的能力，相比原有的主动去查询，数据分发的场景也是非常强大的。例如用户需要发布或者修改了某些服务，通过zookeeper就能轻松地通知众多的用户。

### 集群机器监控
zookeeper可以创建一些临时性的节点，在机器掉线或者主动下线的时候节点会被删除，这个动作也可以通过watcher来让客户端感知。

### Master选举
在分布式系统中，有些业务仅能由一个节点来实现，其他的节点可以共享这个结果，这样可以大大减少重复计算，于是需要进行master选举。
这用到的是zookeeper的有序临时节点的特性，每次我们都讲序号最小的那个节点选举为master。

### 分布式锁
排它锁 
创建一个临时的节点，设置节点的数据为自己的IP，每次读取节点数据时通过判断IP是否为自己来判断是否取得了锁，如果没有则继续监听节点的变化以再次获取锁。
共享锁
~~~
获取读锁过程：
1.	在/lock下创建有序节点read-.
2.	获取/lock下的子节点
3.	如果没有以write-开头且比自己小的节点(无论write或者read-)，则获得了锁
4.	否则监控这个以wirte-开头并且比自己小的节点，直到这个节点被删除,返回2
获取写锁过程:
1.	在/lock下创建有序节点write-
2.	获取/lock下的子节点
3.	如果没有比自己小的节点，则获得了写锁。
4.	否则监控这个比自己小的节点，直到这个节点被删除了，返回2
~~~
### 负载均衡
这个和数据分发类型，不过nginx等工具比它做得更好，所以似乎没有太必要单纯为了实现负载均衡来实现它。
